package dataAccessLayer;

import java.io.Serializable;
import java.text.DateFormat;
import java.util.ArrayList;
import java.util.List;
import javax.faces.bean.ApplicationScoped;
import javax.faces.bean.ManagedBean;
import javax.persistence.EntityManager;
import javax.persistence.TypedQuery;
import helpers.DatabaseConnection;
import helpers.EntitiesManager;
import model.Game;
import model.Player;
import model.PlayerRating;

@ManagedBean(name = "playerDataAccess")
@ApplicationScoped
public class PlayerDataAccess implements Serializable{
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	public static Player FindPlayer(int playerid)
	{
		//EntitiesManager.EM.getTransaction().begin();
		Player player=EntitiesManager.EM.find(Player.class, playerid);
		//em.close();
		return player;
	}
	
	public static Player CreateNewUser(String username, String password,Double rating) {
		Player emp = new Player(username,password,rating);
		emp.setStars(rating.intValue());
		try {
			if(EntitiesManager.EM.getTransaction().isActive()==false)
			{
				EntitiesManager.EM.getTransaction().begin();
			}
			EntitiesManager.EM.persist(emp);
			//EntitiesManager.EM.getTransaction().commit();
			EntitiesManager.EM.refresh(emp);
			//em.close();
		} catch (Exception ex) {
			System.out.println(ex.getMessage());
		}
		return emp;
	}

	public static int loginUser(String username, String password) {	
		//EntitiesManager.EM.getTransaction().begin();
		TypedQuery<Player> query = EntitiesManager.EM.createQuery("SELECT c FROM Player c WHERE c.username = :name AND c.password=:pass", Player.class);
		query.setParameter("name", username);
		query.setParameter("pass", password);
		int result=0;
		try {
			Player player=query.getSingleResult();
			if(player!=null)
			{
				result=player.getId();
			}
		} catch (Exception ex) {
			System.out.println(ex.getMessage());
		}
		//em.close();
		return result;
	}

	public static Player getPlayerWithID(int playerId) {	
		//EntitiesManager.EM.getTransaction().begin();
		Player player =EntitiesManager.EM.find(Player.class, playerId);
		//em.close();
		return player;
	}
	
	public static Player updatePassword(int playerId, String password) {
		//EntitiesManager.EM.getTransaction().begin();
		Player play =EntitiesManager.EM.find(Player.class, playerId);
		try {
			    play.setPassword(password);
			   System.out.println(play.getPassword());
				//em.persist(player);
			   EntitiesManager.EM.getTransaction().commit();
				//em.refresh(player);
				//em.close();
				return play;
		} catch (Exception ex) {
			System.out.println(ex.getMessage());
		}
		return null;
	}

	public static Player updateProfilePicture(int playerId, String newPicture) {
		//EntitiesManager.EM.getTransaction().begin();
		Player play =EntitiesManager.EM.find(Player.class, playerId);
		try {
			    play.setPicture(newPicture);
			    System.out.println(play.getImage());
			    EntitiesManager.EM.merge(play);
			    EntitiesManager.EM.getTransaction().commit();
				//em.close();
				return play;
		} catch (Exception ex) {
			System.out.println(ex.getMessage());
		}
		return null;
	}
	
	public static Player changeAvailable(Player player)
	{	
		//EntitiesManager.EM.getTransaction().begin();
		Player play =EntitiesManager.EM.find(Player.class, player.getId());
		play.setAvailable(player.getAvailable());
		EntitiesManager.EM.persist(play);
		EntitiesManager.EM.getTransaction().commit();
		EntitiesManager.EM.refresh(play);
//		/em.close();
        return play;
	}
	
	public static Player updateRating(int playerId, Double rating)
	{	
		//EntitiesManager.EM.getTransaction().begin();
		Player play =EntitiesManager.EM.find(Player.class,playerId);
		if(play!=null)
		{
			play.setRating(rating);
			play.setStars(play.getRating().intValue());
		}
		EntitiesManager.EM.merge(play);
		EntitiesManager.EM.getTransaction().commit();
		EntitiesManager.EM.refresh(play);
		//em.close();
        return play;
	}

	public static List<Player> ListAllPlayers() {

		//EntitiesManager.EM.getTransaction().begin();
		    TypedQuery<Player> query =EntitiesManager.EM.createQuery("SELECT p FROM Player p",Player.class);
			List<Player> result = new ArrayList<Player>();
			result = query.getResultList();
			for(Player p:result)
			{
				System.out.println(p.getUsername());
			}
			//em.close();
			return result;
	}

	  public static boolean RemovePlayer(int playerId) {
		 // EntitiesManager.EM.getTransaction().begin();
			Player player=EntitiesManager.EM.find(Player.class, playerId);
			if(player!=null)
			{			
				player.setArchive(true);
				EntitiesManager.EM.getTransaction().commit();
				//EntitiesManager.EM.close();
				return true;
			}
			else
			{
				System.out.println("Player not found");
				return false;
			}
		}
	  
	  public static boolean DeleteRatingsBeforeGame(int playerId,int gameId) {
		  //EntitiesManager.EM.getTransaction().begin();
			Player player=EntitiesManager.EM.find(Player.class, playerId);
			Game game=EntitiesManager.EM.find(Game.class, gameId);
			
			if(player!=null && game!=null)
			{		
				System.out.println("Player games:");
				for(Game g:player.getGames())
				{
					System.out.println(g.toString());
				}
				System.out.println("Player ratings:");
				for(PlayerRating pl:player.getPlayerRatings())
				{
					System.out.println(pl.toString());
				}			
				if(player.hasRatingForGame(game))
				{
					System.out.println("There is already rating for this game!");
					for(PlayerRating pl:player.getPlayerRatings())
					{
						if((pl.getDate().after(game.getDate())) || (pl.getDate().compareTo(game.getDate())==0) )
						{
							PlayerRatingAccess.DeleteRating(pl.getId());
						}
					}
					return true; //daca s-au sters rating-uri si pentru alte jocuri
				}
				else
				{
					System.out.println("There is no rating for this game!");
				}
			}
			EntitiesManager.EM.getTransaction().commit();
			//em.close();
			return false; //daca nu are ratinguri de sters
		}
	  
	  public static Player UpdateLastValidRating(int playerId)
	  {
		  //EntitiesManager.EM.getTransaction().begin();
			Player player=EntitiesManager.EM.find(Player.class, playerId);
			if(player!=null)
			{
				player.setRating(player.getLastRating());
				player.setStars(player.getRating().intValue());
				System.out.println("last rating is: "+player.getRating());
				EntitiesManager.EM.merge(player);
				EntitiesManager.EM.getTransaction().commit();
				EntitiesManager.EM.refresh(player);
			}
			//em.close();
			return player;
	  }
	  
	  public static Player NewRatingForGame(int playerId,int gameId)
	  {
		  //.EM.getTransaction().begin();
			Player player=EntitiesManager.EM.find(Player.class, playerId);
			Game game=EntitiesManager.EM.find(Game.class, gameId);
			if(player!=null && game!=null)
			{
				System.out.println("Current player rating: "+player.getRating());
				System.out.println("Game difference: "+game.getDifference());
				if(game.getTeam1().containsPlayer(player))
				{
					if(game.getTeam1().getWinner())
					{
						player.setRating(player.getRating()+(game.getDifference()*0.01));
					}
					else
					{
						player.setRating(player.getRating()-(game.getDifference()*0.01));
					}
				}
				else
				{
					if(game.getTeam2().containsPlayer(player))
					{
						if(game.getTeam2().getWinner())
						{
							player.setRating(player.getRating()+(game.getDifference()*0.01));
						}
						else
						{
							player.setRating(player.getRating()-(game.getDifference()*0.01));
						}
					}
				}
				EntitiesManager.EM.merge(player);
				EntitiesManager.EM.getTransaction().commit();
				EntitiesManager.EM.refresh(player);
			}
			//em.close();
			return player;
	  }
	  	  
public static List<Player> ListActivePlayers() {	
	if(EntitiesManager.EM.getTransaction().isActive()==false)
	{
		EntitiesManager.EM.getTransaction().begin();
	}
	TypedQuery<Player> query = EntitiesManager.EM.createQuery("SELECT p FROM Player p WHERE p.archive = false", Player.class);
	List<Player> result = new ArrayList<Player>();
	result = query.getResultList();
	return result;
	 }
	  
	  
	  
	  public static void main(String[] args) {
		  Game g1=GameDataAccess.GetGame(47);
		  Game g2=GameDataAccess.GetGame(52);
		  long startDate = g1.getDate().getTime();
		  long endDate =g2.getDate().getTime();

		  long diffTime = Math.abs(startDate - endDate);
		  long diffDays = diffTime / (1000 * 60 * 60 * 24);
		  DateFormat dateFormat = DateFormat.getDateInstance();
		  System.out.println("The difference between "+
		    dateFormat.format(startDate)+" and "+
		    dateFormat.format(endDate)+" is "+
		    diffDays+" days.");
		 
	  }
}