package dataAccessLayer;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

import model.Player;

public class TeamGenerator {

	public static int factorial(int number)
	{
		int result=1;
		for(int i=1;i<=number;i++)
		{
			result*=i;
		}
		return result;
	}
	
	public static int Combination(int n,int k)
	{
		return factorial(n)/(factorial(k)*factorial(n-k));
	}
	
    
	public static List<List<Player>> resultList=new ArrayList<List<Player>>();
	
	static double totalValue=0;
	
	public static void ListCombinations()
	{
		System.out.println("There are "+resultList.size()+" teams");
		 for(List<Player> l:resultList)
		 {
			 for(Player p:l)
			 {
				 System.out.println(p.getUsername());
			 }
		 }
	}
	
	public static void ListTreeMap(TreeMap<Double,List<Player>> map)
	{
		for(double v:map.keySet())
		{
			System.out.println(v+ " "+map.get(v).size());
		}
	}
	
	public static void GetTotalValue(List<Player> players)
	{
			 for(Player p:players)
			 {
				 totalValue+=p.getRating();
				 //System.out.println(p.getUsername());
			 }
			 System.out.println("first"+totalValue);
			 totalValue=totalValue/2;
			 
	}
	
    public static void  getCombinations(Player[] arr, int len, int startPosition, Player[] result){
    		  
        if (len == 0){
        	
        	resultList.add(Arrays.asList(result));
        	
        	//System.out.println("Team");
        	
        	List<Player> lisst=new ArrayList<Player>();
        	for(Player p:Arrays.asList(result))
        	{
        		lisst.add(p);
        		//System.out.println(p.getUsername());
        	}
        	resultList.add(lisst);
            return;
        }            
        for (int i = startPosition; i <= arr.length-len; i++){
            result[result.length - len] = arr[i];
            getCombinations(arr, len-1, i+1, result);
        }
    }  

    
	public static  TreeMap<Double,List<Player>> generateTeams()
	{
		//lista care va fi returnata
		TreeMap<Double,List<Player>> map = new TreeMap<Double, List<Player>>(
				new Comparator<Double>() {


				@Override
				public int compare(Double arg0, Double arg1) {
					if(Math.abs((totalValue-arg0))<Math.abs((totalValue-arg1)))
					{
						return -1;
					}
					if(Math.abs((totalValue-arg0))>Math.abs((totalValue-arg1)))
					{
						return 1;
					}
					return 0;
				}

			});
		 
		 //valoarea totala a echipei
		 double idealValue=0;
		 
		 for(List<Player> list:resultList)
	        {
			 	idealValue=0;
	        	System.out.println("combination:");
	        	for(Player p:list)
	        	{
	        		idealValue+=p.getRating();
	        		System.out.println(p.getUsername());
	        	}
	        	map.put(idealValue, list);
	        	System.out.println("Strength "+idealValue);
	        }
		 return map;
		
	}

	public static double Getteam(List<Double> list)
	{
		double result=compare(list.get(0),list.get(1));
			
		return result;
	}
	
	public static double compare(double d1,double d2)
	{
		if((totalValue-d1)<=(totalValue-d2))
		{
			return d1;
		}
		return d2;
	}
	

public static double minFromMap(List<Double> set) {

	double min=Math.abs(totalValue-(set.get(0)));
	System.out.println("Initial min:"+min);
	int indexToReturn=0;
	for(int i=1;i<set.size();i++)
	{
		if(Math.abs((totalValue-set.get(i)))<min)
		{
			min=Math.abs(totalValue-set.get(i));
			System.out.println("Min:"+min);
			indexToReturn=i;
		}
	}
	
	return set.get(indexToReturn);
	}

	public static void printMap(Map<Double,List<Player>> map) {
		
		for (Map.Entry<Double, List<Player>> entry : map.entrySet()) {
			
			System.out.println("Key : " + entry.getKey() 
                                      + " Value : " + entry.getValue());
		}
	}
	
	public static void main(String[] args) {
		//fac un ob player data access
		PlayerDataAccess pda=new PlayerDataAccess();
		List<Player> list=new ArrayList<Player>();
		list=pda.listPlayers();
		//transform lista in array
		Player[] array = new Player[list.size()];
		list.toArray(array); 
		
		GetTotalValue(list);
		System.out.println("Total value" +totalValue);
		//generez toate perechile posibile
		getCombinations(array, 3, 0,new Player[3]);
		
		//ListCombinations();
		 
		TreeMap<Double,List<Player>> map = new TreeMap<Double, List<Player>>(
				new Comparator<Double>() {


				@Override
				public int compare(Double arg0, Double arg1) {
					if(Math.abs((totalValue-arg0))<Math.abs((totalValue-arg1)))
					{
						return -1;
					}
					if(Math.abs((totalValue-arg0))>Math.abs((totalValue-arg1)))
					{
						return 1;
					}
					return 0;
				}

			});
		
		// TreeMap<Double,List<Player>> map = new TreeMap<Double,List<Player>>(new Comparator<Integer>());
		 map=generateTeams();
		 List<Double> lista=new ArrayList<Double>();
		 for(double d:map.keySet())
		 {
			 lista.add(d);
		 }
		 System.out.println(minFromMap(lista));
		 
		 printMap(map);
		 //ListTreeMap(map);
//		 for(double d:map.keySet())
//		 {
//			// System.out.println("Team");
//			 for(Player player:map.get(d))
//			 {
//				 
//				 //System.out.println(player.getUsername());
//			 }
//		 }
		//generez o Map in care pentru fiecare echipa am un scor total
		//ListCombinations();
	}
}
